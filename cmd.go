package ctw

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"io"
	"os"
)

// Compress compresses the named file using arithmetic coding supplied with a Context Tree Weighting probabilistic model of depth depth.
// The compressed result is written to w.
func Compress(w io.Writer, name string, depth int) error {
	// Write file size
	fi, err := os.Stat(name)
	if err != nil {
		return err
	}
	buf := new(bytes.Buffer)
	err = binary.Write(buf, binary.BigEndian, fi.Size())
	if err != nil {
		return err
	}
	if _, err = w.Write(buf.Bytes()); err != nil {
		return err
	}

	// Send file contents to encoder through the src channel.
	f, err := os.Open(name)
	if err != nil {
		return err
	}
	defer f.Close()
	src := make(chan int)
	errc := make(chan error, 1)
	// We allow the reader to terminate early via a stopReader channel,
	// in case for example, a downstream error occured when writing to w.
	stopReader := make(chan struct{}, 1)
	go func() {
		defer close(src)
		errc <- func() error {
			scanner := bufio.NewScanner(f)
			scanner.Split(bufio.ScanBytes)
			for scanner.Scan() {
				var bt byte = scanner.Bytes()[0]
				for i := uint(0); i < 8; i++ {
					select {
					case src <- ((int(bt) & (1 << i)) >> i):
					case <-stopReader:
					}
				}
			}
			if err := scanner.Err(); err != nil {
				return err
			}
			return nil
		}()
	}()

	// Collect encoded bits into bytes and write to w
	dst := make(chan int)
	dsterrc := make(chan error, 1)
	go func() {
		dsterrc <- func() error {
			defer func() { stopReader <- struct{}{} }()
			buf := []byte{0}
			var bt *byte = &buf[0]
			var i uint = 0
			for b := range dst {
				if b == 1 {
					*bt |= (1 << i)
				}
				i += 1

				if i == 8 {
					if _, err := w.Write(buf); err != nil {
						return err
					}
					*bt = 0
					i = 0
				}
			}
			if i > 0 {
				if _, err := w.Write(buf); err != nil {
					return err
				}
			}
			return nil
		}()
	}()

	model := NewCTW(make([]int, depth))
	Encode(dst, src, model)

	if err := <-errc; err != nil {
		return err
	}
	if err := <-dsterrc; err != nil {
		return err
	}
	return nil
}

// Decompress decompress a compressed stream of bytes generated by Compress.
// Decompress reads the compressed bytes from r, and writes the decompressed result to w.
// Decompress expects the same Context Tree Weighting depth used in Compress.
func Decompress(w io.Writer, r io.Reader, depth int) error {
	var numBytes int64
	err := binary.Read(r, binary.BigEndian, &numBytes)
	if err != nil {
		return err
	}

	// Read bits from r and send them to the decoder through the src channel.
	// Errors during reading are surfaced through the errc channel.
	// Since the last byte might contain superfluous bits not belonging to the encoded result (there is no reason why the number of encoded bits should be multipies of 8),
	// we need a stopReader channel to avoid the reader goroutine from blocking indefinitely..
	src := make(chan int)
	srcErrc := make(chan error, 1)
	stopReader := make(chan struct{}, 1)
	go func() {
		defer close(src)
		srcErrc <- func() error {
			scanner := bufio.NewScanner(r)
			scanner.Split(bufio.ScanBytes)
			for scanner.Scan() {
				var bt byte = scanner.Bytes()[0]
				for i := uint(0); i < 8; i++ {
					select {
					case src <- ((int(bt) & (1 << i)) >> i):
					case <-stopReader:
						return nil
					}
				}
			}
			if err := scanner.Err(); err != nil {
				return err
			}
			return nil
		}()
	}()

	// Collect decoded bits and write them out as bytes.
	// Upon completion or error, signal the reader goroutine to terminate via the stopReader channel.
	dst := make(chan int)
	dstErrc := make(chan error, 1)
	go func() {
		dstErrc <- func() error {
			defer func() { stopReader <- struct{}{} }()
			buf := []byte{0}
			var bt *byte = &buf[0]
			var i uint = 0
			for b := range dst {
				if b == 1 {
					*bt |= (1 << i)
				}
				i += 1

				if i == 8 {
					if _, err := w.Write(buf); err != nil {
						return err
					}
					*bt = 0
					i = 0
				}
			}
			if i > 0 {
				if _, err := w.Write(buf); err != nil {
					return err
				}
			}
			return nil
		}()
	}()

	model := NewCTW(make([]int, depth))
	decodeErr := Decode(dst, src, model, numBytes*8)

	if err := <-srcErrc; err != nil {
		return err
	}
	if err := <-dstErrc; err != nil {
		return err
	}
	if decodeErr != nil {
		return decodeErr
	}
	return nil
}
